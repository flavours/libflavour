import attr

from libflavour.exceptions import ValidationError
from slugify import slugify
from strictyaml import Bool, Int, Map, Optional, Str


NOT_SET = object()


@attr.s
class BaseField:

    type = attr.ib()  # The type/identifier of the widget
    name = attr.ib()  # System name of the setting
    label = attr.ib()  # Human readable label of the setting
    parent = attr.ib(default=None)  # Optional reference to the parent entity
    _variable = attr.ib(
        default=None
    )  # Optional attribute to specify the name of the variable in the environment. If not set, it should be autogenerated from the name
    helptext = attr.ib(default="")  # Human readable help text
    default = attr.ib(default=NOT_SET)  # Default value if nothing is provided
    visibility = attr.ib(
        default=0
    )  # Visibility level, 0 = very public, 1 = advanced, 2 = dangerous
    required = attr.ib(
        default=True
    )  # Boolean if this value must be set. There is some interaction with "default"
    readonly = attr.ib(default=False)  # Can this value be changed
    value = attr.ib(default=NOT_SET)  # The saved value of the field, if any

    @classmethod
    def schema(cls):
        basic_schema = {
            # `name` is not part of the sub schema, name is the title of the block.
            # `default` must be provided in the sub schemas
            "label": Str(),
            "type": Str(),
            Optional("variable"): Str(),
            Optional("helptext"): Str(),
            Optional("visibility"): Int(),
            Optional("required"): Bool(),
            Optional("readonly"): Bool(),
        }

        return Map(basic_schema)

    @property
    def variable(self):
        if self._variable:
            return self._variable

        # Generate a variable name if it is not set yet
        path = []
        if self.parent:
            path.append(self.parent.name)
        path.append(self.name)

        return slugify("_".join(path)).upper().replace("-", "_")

    @property
    def __dict__(self):
        return self.data

    @property
    def data(self):
        basic_data = {
            "name": self.name,
            "type": self.type,
            "label": self.label,
            "variable": self.variable,
            "helptext": self.helptext,
            "visibility": self.visibility,
            "required": self.required,
            "readonly": self.readonly,
            "value": None if self.value is NOT_SET else self.value,
        }
        if self.default is not NOT_SET:
            basic_data["default"] = self.default
        return basic_data

    def to_python(self, value):
        """
        Casts the value to the Python type.

        Might raise ValidationError if the type cast is not possible.
        """
        return value

    def validate(self):
        # check if the combination of value, default, and required is correct
        if self.value is NOT_SET:
            if self.default is NOT_SET and self.required:
                raise ValidationError("This is a required field")
        else:
            self.value = self.to_python(self.value)
