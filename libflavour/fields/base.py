import attr

from libflavour.exceptions import ValidationError
from slugify import slugify
from strictyaml import Bool, Int, Map, Optional, Str


NOT_SET = object()


@attr.s
class BaseField:

    type = attr.ib()  # The type/identifier of the widget
    name = attr.ib()  # System name of the setting
    label = attr.ib()  # Human readable label of the setting
    parent = attr.ib(default=None)  # Optional reference to the parent entity
    _variable = attr.ib(
        default=None
    )  # Optional attribute to specify the name of the varialbe in the environment. If not set, it should be autogenerated from the name
    helptext = attr.ib(default="")  # Human readable help text
    default = attr.ib(default=NOT_SET)  # Default value if nothing is provided
    visibility = attr.ib(
        default=0
    )  # Visibility level, 0 = very public, 1 = advanced, 2 = dangerous
    required = attr.ib(
        default=True
    )  # Boolean if this value must be set. There is some interaction with "default"
    readonly = attr.ib(default=False)  # Can this value be changed
    _value = NOT_SET  # The saved value of the field, if any

    @classmethod
    def schema(cls):
        basic_schema = {
            # `name` is not part of the sub schema, name is the title of the block.
            # `default` must be provided in the sub schemas
            "label": Str(),
            "type": Str(),
            Optional("variable"): Str(),
            Optional("helptext"): Str(),
            Optional("visibility"): Int(),
            Optional("required"): Bool(),
            Optional("readonly"): Bool(),
        }

        return Map(basic_schema)

    @property
    def variable(self):
        if self._variable:
            return self._variable

        # Generate a variable name if it is not set yet
        path = []
        if self.parent:
            path.append(self.parent.name)
        path.append(self.name)

        return slugify("_".join(path)).upper().replace("-", "_")

    @variable.setter
    def variable(self, variable):
        self._variable = variable

    @property
    def value(self):
        if self._value is NOT_SET:
            if self.default is NOT_SET:
                if self.required:
                    raise ValueError(
                        f"{self.name} value defined and no default"
                    )
                else:
                    return None
            else:
                return self.default

        else:
            return self._value

    @value.setter
    def value(self, value):
        self._value = value

    @property
    def __dict__(self):
        return self.data

    @property
    def data(self):
        basic_data = {
            "name": self.name,
            "type": self.type,
            "label": self.label,
            "variable": self.variable,
            "helptext": self.helptext,
            "visibility": self.visibility,
            "required": self.required,
            "readonly": self.readonly,
            "value": self.value,
        }
        if self.default is not NOT_SET:
            basic_data["default"] = self.default
        return basic_data

    def validate(self):
        # check if the value, default required combination is correct
        try:
            self.value
        except ValueError as e:
            raise ValidationError(str(e))
